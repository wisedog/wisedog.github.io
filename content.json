{"pages":[{"title":"About","text":"김종하 (Jongha Kim)역사와 프로그래밍을 좋아합니다. 취미로 돈은 안되지만 이것저것 서비스 만드는 걸 좋아합니다. ExperienceShipda (2020.02 ~ ) CTO A-Team Ventures (2018.08 ~ 2020.02)loplat (2016.11 ~ 2018.07)파수닷컴 (2013.3 ~ 2016.11)버즈니 (2011.7 ~ 2013.3)삼성전자 (2007.1 ~ 2011.7) Personal Activity 출판 : 역사 속의 소프트웨어 오류. 에이콘출판사, 2014 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"},{"title":"프로그래밍","text":"상황별로 보는 타입스크립트상황별로 보는 타입스크립트 - Typescript By Example 파이썬 고급예외처리모듈패키지 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/programming/index.html"},{"title":"상황별로 써먹는 타입스크립트","text":"enum element 검증하기 enum element 검증하기보통 API의 파라미터가 enum의 엘레먼트인지 검증하기 위해서 사용한다. 어떤 값이 enum 안의 element 에 속하는지 여부를 볼 때는 아래와 같이 사용한다. 123456789enum Drink { Beer = &apos;beer&apos;, Soju = &apos;soju&apos;, Whisky = &apos;whisky&apos;,}if (Object.values(Drink).includes(someVar)) { // someVar가 Drink enum에 속할 경우} 만약 error TS2339: Property &apos;values&apos; does not exist on type &apos;ObjectConstructor&apos;. 에러 메시지가 뜨면 es2017을 타겟팅하지 않아서 생긴 문제다. 해결 방법은 2개인데 첫 번째는 tsconfig.json 설정을 바꾼다.123&quot;compilerOptions&quot;: { &quot;lib&quot;: [&quot;es2017&quot;]} 두 번째는 any 캐스팅을 추가하는 일이다.123if ((&lt;any&gt;Object).values(Drink).includes(someVar)) { // someVar가 Drink enum에 속할 경우} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/programming/typescript/by_example/index.html"}],"posts":[{"title":"ECMAScript use strict 사용하기","text":"“use strict” 은 자바스크립트 코드를 좀 더 엄격한(strict) 모드에서 실행하도록 인터프리터에게 명령하는 자바스크립트의 지시자(directive)다. 좋은 점 3가지 코딩 실수 대신 에러를 낸다. 따라서 프로그래머는 자신의 실수를 쉽게 알아차릴 수 있다. 보통 엄격 모드에서 실행속도가 빠르다라고 알려져 있다. 직접 테스트를 안해봐서 알 수는 없지만, 엄격 모드에서는 인터프리터의 최적화 작업을 어렵게 만드는 문법을 금지시키기 때문에 빠르다. ECMAScript의 차기 버전들에서 정의 될 문법을 사용하지 못한다. ‘엄격 모드’를 사용하면 생기는 제한이 ‘엄격 모드’로 자바스크립트 코드를 실행하고자 하면 은은하게 많은 제한이 생긴다. 주석은 크롬 콘솔에서 실행했을 때 발생하는 에러다. 생성하지 않은 변수를 사용할 수 없다. 자바스크립트에서는 실수로 변수명을 잘못 적었다면 에러를 내지 않고 그냥 새로운 전역 변수가 생성되는데, strict 모드를 사용하면 이를 막을 수 있다. 12&quot;use strict&quot;;pi = 3.1415; // Uncaught ReferenceError: pi is not defined 변수나 함수, 삭제할 수 없는 속성을 삭제할 수 없다. 123456&quot;use strict&quot;;var pi = 3.14;delete pi; function f(p1, p2) {};delete f; // Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.delete Object.prototype; // TypeError: property &quot;prototype&quot; is non-configurable and can&apos;t be deleted 파라미터 이름을 중복으로 쓸 수 없다. 12&quot;use strict&quot;;function f(p1, p1) {}; // SyntaxError: duplicate formal argument p1 8진수 리터럴, 8진수 이스케이프 문자를 사용할 수 없다. 123&quot;use strict&quot;;var oct = 010; // Uncaught SyntaxError: Octal literals are not allowed in strict modevar oct1 = &quot;\\010&quot;; // Uncaught SyntaxError: Octal escape sequences are not allowed in strict mode. 읽기 전용 속성이나 GET 전용 속성을 다시 쓸 수 없다. 123456&quot;use strict&quot;;var obj = {get z() {return 0} };Object.defineProperty(obj, &quot;x1&quot;, {value:123, writable:false});obj.x1 = &quot;hello&quot;; // Uncaught TypeError: Cannot assign to read only property &apos;x1&apos; of objectobj.z = &quot;world&quot;; // Uncaught TypeError: Cannot set property z of #&lt;Object&gt; which has only a getter 몇 가지 키워드를 변수명으로 사용할 수 없다. 123&quot;use strict&quot;;var eval = &apos;hello&apos;; // SyntaxError: &apos;eval&apos; can&apos;t be defined or assigned to in strict mode codevar arguments = &apos;world&apos;; // SyntaxError: &apos;arguments&apos; can&apos;t be defined or assigned to in strict mode code 브라우저 지원2009년 ECMAScript 5에서 처음 나온 기능으로 IE9과 그 이전 IE에서는 strict 모드를 지원하지 않는다. 다만 이전 브라우져에서 큰 문제는 되지 않는데, 이전 브라우져에서는 문법적(BNF)으로 보면 “use strict”를 그저 리터럴 표현으로 인식하기 때문에 side effect 를 발생시키지 않고 따라서 그냥 무시될 뿐이다. strict 모드를 지원하는 브라우져는 아래와 같다. 크롬 버전 10 이상 파이어폭스 버전 4 이상 사파리 버전 5.1 이상 IE 버전 10 이상 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/05/24/ECMAScript-use-strict-사용하기/"},{"title":"구글 앱 엔진 2018 하반기 소식 모음","text":"간만에 블로그 글을 씁니다. 2018년 하반기 구글 앱엔진에 굵직한 업데이트가 있었습니다. Python3 지원얼마전까지도 파이썬2의 종료일자는 다가오는데 구글측에서는 파이썬3를 지원 예정이라고만 언급해서 애를 태웠습니다. 그런데 2018년 8월 8일, 드디어 파이썬3 런타임을 베타로 지원하기 시작했고 어제인 12월 14일 GA로 올라왔습니다. 지원 런타임은 3.7입니다. 파이썬2에서 파이썬3로 올라오면서 굉장히 많은 변화가 생겼습니다. 기존 파이썬2 앱엔진은 제한된 샌드박스 위에서 구동되는 방식이었습니다. 그래서 사용할 수 있는 라이브러리와 버전도 굉장히 제한적이었고 파일 접근은 물론이요 네트워크까지 제약이 굉장히 많았습니다. 그래서 아무리 장고, 플라스크 앱이라도 구글 앱엔진용으로 수정을 해야 사용할 수 있었습니다. 하지만 파이썬3 앱엔진은 gVisor 콘테이너 런타임 기술을 사용해서\b /tmp 를 마음대로 쓸 수 있으며 아무 라이브러리를 설치해서 쓸 수 있습니다. 기본 웹서버를 nginx로 변경별 영향은 없다네요. 새로운 사용 가용 리전us-west2(로스 엔젤레스), asia-east2(홍콩) 리전에서 앱 엔진을 사용할 수 있습니다. 참고 : 구글 클라우드 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/12/15/Google-AppEngine-news-2018-half-later/"},{"title":"Firebase 한글 문서는 안보는게 좋겠다","text":"지난 2월달에 Google Cloud + Firebase 를 사용해서 펫 프로젝트를 만들고 있을 때였다. 해당 펫 프로젝트는 아래와 같이 테크 스택을 꾸렸다.API: Google AppEngine - PythonFront: Vue.jsStatic Hosting: Firebase Static Web HostingDB: Firebase Firestore이 조합을 선택한 이유는 Firebase Auth를 그대로 JWT로 쓸 수 있어서 또 다른 인증체계가 필요없기 때문이었다. OIDC나 Oauth2를 처리하려면 얼마나 귀찮은가! (그리고 Firebase Static Web Hosting 좋아요. Netlify 도 좋긴한데 파이어베이스 호스팅도 좋습니다.) 이렇게 시간날때마다 API를 만들던 도중 Firestore 쪽에서 문제를 만났다. 유닛 테스트를 하는데 계속 업데이트 API쪽에서 계속 테스트가 실패했다. 코드는 대략 이랬는데,12345inspection_ref = db.collection(&apos;inspection&apos;).document(commitId)inspection_ref.update({ &apos;status&apos;: 3}, firestore.CreateIfMissingOption(True)) 계속 firestore.CreateIfMissingOption 이 없다고 에러가 발생했다. (참고로 원래 update 동작 방식은 문서가 있으면 덮어쓰는 방식인데 기존 데이터와 병합하고 싶을 때 CreateIfMissingOption을 씁니다). 아 이상하네https://firebase.google.com/docs/firestore/manage-data/add-data?hl=ko 에 있는 방식대로 그대로 했는데…… 구글 놈들이 문서를 잘못 쓸 일은 없고…. Google Cloud API 저장소를 뒤져서 그 이유를 찾아냈다. google-cloud-python 저장소의 4851 PR에서 해당 방식이 merge=boolean 방식으로 변경된 것이다. 즉 아까 예제코드는123inspection_ref.update({ &apos;status&apos;: 3}, merge=True) 식으로 고치니 잘 동작한다. 혹시혹시혹시나 해서 영어판 파이어스토어 문서를 봤더니 여긴 업데이트가 되어있다. 즉, 제대로 업데이트가 안된 한글 문서가 문제였다. 한글 문서는 2018년 5월 29일에 최종 업데이트 되었고, 그 사이 변경된 사항을 업데이트하지 않았다. 곧바로 구글에 이메일을 보냈다. 맨 처음엔 파이어베이스 오른쪽 위에 있는 “의견보내기”를 눌러서 리포트를 했는데 영 답이 없었다. 그래서 아예 파이어베이스 고객지원쪽을 통해서 해당 내옹을 리포트 했다. 물론 담당 엔지니어는 알려줘서 정말 감사하고 빠른 시간내에 리포트해서 고치겠다는 상투적인 답변을 했지만 2019년 2월 19일에 보고했던 문제는 2개월이 다 된 지금도 해결되지 않았다. 앞으로 구글 파이어베이스 문서를 보실 분은 한글문서 보지말고 영어 문서를 보길 바란다. ~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/04/14/do-not-believe-korean-firebase-docs/"},{"title":"Jest로 Express 테스트하기","text":"Jest로 Express API 유닛 테스트를 할 때 겪었던 문제를 다른 사람들도 안 겪었으면 하는 바램에서 글을 썼다. 원래 유닛 테스트는 Mocha와 Chai를 사용했는데 이번에 한 번 Jest로 테스트 프레임워크를 바꿔보았다. Jest를 사용하기 위해서는 일단 Install. 1npm install --save-dev babel-cli, babel-preset-env, jest, supertest 아래는 간단한 웹 서버 코드다. 1234567891011121314151617// app.jsimport express from &apos;express&apos;;const app = express();const port = 3000;app.get(&apos;/hello&apos;, (req, res) =&gt; { res.send(&apos;world!&apos;);});app.get(&apos;/status&apos;, (req, res) =&gt; { res.send(&apos;ok&apos;);});app.listen(port);module.exports = app; 매우 간단한 이 웹 서버는 두 개의 라우트(/hello, /status)밖에 없다. /hello 라우트는 단순하게 “world!” 문자열만 리턴하며 /status는 단순하게 “ok” 문자열만 리턴한다. 이제 Jest와 Supertest를 사용해서 이 라우트를 테스트를 해보겠다. 먼저 /hello 123456789101112// tests/hello.test.jsimport request from &apos;supertest&apos;;import app from &apos;../app&apos;;describe(&apos;Test /hello&apos;, () =&gt; { it (&apos;should return world!&apos;, (done) =&gt; { request(app).get(&apos;/hello&apos;).then((response) =&gt; { expect(response.text).toBe(&apos;world!&apos;); done(); }); });}); Test! 깔끔하게 성공한 것을 볼 수 있다. 그럼 이제 /status에 대한 테스트를 해보자. 이 테스트는 다른 파일에 작성하도록 한다. 물론 식은 죽 먹기다. 123456789101112// tests/status.test.jsimport request from &apos;supertest&apos;;import app from &apos;../app&apos;;describe(&apos;Test /status&apos;, () =&gt; { it (&apos;should return ok&apos;, (done) =&gt; { request(app).get(&apos;/status&apos;).then((response) =&gt; { expect(response.text).toBe(&apos;ok&apos;); done(); }); });}); Test!   당연히 성공할 줄 알았던 테스트가 EADDRINUSE 에러를 내면서 실패했다. 문제는 첫 번째 테스트를 실행하면서 서버는 아직도 3000번 포트를 listen 하고 있기 때문이다. 그래서 두 번째 테스트에서 다시 import app from ‘../app’ 을 실행하면 이전 테스트에서 이미 listen하고 있는 3000번 포트를 다시 사용하기 때문에 문제가 발생한 것이었다. 이 문제를 해결하기 위해서는 테스트가 아닐 경우에만 3000번 포트를 열도록 변경해야 한다. 어차피 테스트 환경일 경우에는 Supertest를 통해서 서버를 구동하기 때문에 네트워크 포트를 열 필요가 없다. 따라서 package.json을 아래와 같이 바꾼다. 12345{ &quot;scripts&quot;: { &quot;unit&quot;: &quot;NODE_ENV=test jest tests/*.test.js --forceExit&quot;, }} 그리고 app.js를 아래와 같이 바꾼다. 1234// ...if (process.env.NODE_ENV !== &apos;test&apos;) { app.listen(port);} 다시 한 번 실행하면 성공! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/04/04/how-to-use-jest-with-express-js/"},{"title":"go 언어 구글 클라우드 Datastore 패키지를 잘 씁시다!","text":"3월 초에 시간이 좀 많이 나서 펫 프로젝트를 진행한 일이 있다. 구글 클라우드에서 AppEngine Standard Environment + Datastore으로 프로젝트를 구성했다. AppEngine은 복습할 겸 회사에서 지겹도록 파이썬을 써서 Go언어로 만들었다. API는 쉽게 구현할 수 있었다. 다만 문제는 속도가 너무 느렸다. 아래는 대략적인 코드다. 1234567891011121314151617181920212223242526272829303132package mypetprojectimport ( &quot;context&quot; &quot;net/http&quot; &quot;github.com/gorilla/mux&quot; &quot;cloud.google.com/go/datastore&quot; &quot;google.golang.org/appengine&quot;)func handleTable(w http.ResponseWriter, r *http.Request) { ctx := appengine.NewContext(r) dsClient, err := datastore.NewClient(ctx, &quot;my-project&quot;) if err != nil { // Handle error. } k := datastore.NameKey(&quot;Entity&quot;, &quot;stringID&quot;, nil) e := new(Entity) if err := dsClient.Get(ctx, k, e); err != nil { // Handle error. } // ...}func init() { r := mux.NewRouter() r.HandleFunc(&quot;/table&quot;, handleTable).Methods(&quot;GET&quot;) http.Handle(&quot;/&quot;, r)} 하나의 Kind(관계형DB의 Table)에 몇 개 되지도 않은 Entity(관계형DB의 Row)만 있고 단순한 GET 만을 했을 뿐인데 속도가 600~800ms 나 걸렸다! 제일 의심이 가던 부분은 datastore.NewClient()였다. 이 함수에서 Datastore에 연결하는데 오래 걸리리라 생각했다. 그래서 이를 패키지 전역으로 빼려고 했으나 실패. datastore.NewClient()의 인자로 context를 받는데, 이 context는 appengine의 context 를 받아야 했다. 1func NewClient(ctx context.Context, projectID string, opts ...option.ClientOption) (*Client, error) 구글이 이렇게 허접하게 만들었을리 없는데, 뭔가 다른 방법이 있지 않을까 하고 낑낑대던 와중에 눈에 띈 패키지명이 있었다. 바로 google.golang.org/appengine/datastore … 내가 사용했던 Datastore 패키지와 달랐다. 정리하자면google.golang.org/appengine/datastore는 Google App Engine Standard Environment에서 사용하는 패키지다. godoc에서 확인해보면 맨 첫 머리에 아래와 같은 설명이 있다. Package datastore provides a client for App Engine’s datastore service. 그렇다. google.golang.org/appengine/datastore 패키지는 App Engine Standard Environment 전용이며, 그 외에 로컬이나 Compute Engine, App Engine Flexible Environment에서 사용할 때는 cloud.google.com/go/datastore 를 사용해야 한다. App Engine에서 부를때는 Client를 만드는 부분, 즉 인증, 연결 부분이 생략되어 있기 때문에 코드가 다음과 같이 조금 더 간단해졌다. 또한 응답시간 역시 기존 600~800ms에서 모두 80ms 아래로 떨어뜨릴 수 있었다. 1234567891011121314151617181920212223242526272829package mypetprojectimport ( &quot;context&quot; &quot;net/http&quot; &quot;github.com/gorilla/mux&quot; &quot;google.golang.org/appengine&quot; &quot;google.golang.org/appengine/datastore&quot;)func handleTable(w http.ResponseWriter, r *http.Request) { ctx := appengine.NewContext(r) k := datastore.NewKey(ctx, &quot;Entity&quot;, &quot;stringID&quot;, 0, nil) e := new(Entity) if err := datastore.Get(ctx, k, e); err != nil { http.Error(w, err.Error(), 500) return } // ...}func init() { r := mux.NewRouter() r.HandleFunc(&quot;/table&quot;, handleTable).Methods(&quot;GET&quot;) http.Handle(&quot;/&quot;, r)} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/03/28/hello-world/"},{"title":"구글 앱 엔진 파이썬3 변경사항","text":"구글 엡 엔진 파이썬3(Standard Environment)에서는 기존과 많은 점이 변경되었습니다. gVisor 컨테이너 런타임의 영향으로 기존의 Flexible Environment에 가깝게 바뀌었는데요. 최신 런타임파이썬 2.7 -&gt; 파이썬 3.7 /tmp에 파일 입출력 가능기존 파이썬2에는 파일 입출력이 불가능해서 /tmp을 쓰는 파이썬 라이브러리가 제대로 작동하지 않는 문제가 있었습니다. 이번 파이썬3 런타임에서는 /tmp에 파일 입출력이 가능합니다. 써드파티 라이브러리 설치 제약 해제기존 파이썬 2.7 런타임에서는 사용 가능 라이브러리에 제약이 있었습니다. Whitelist 방식으로 사용 가능한 라이브러리 외에는 다 안되는 방식이었는데, 이번에는 어떠한 써드파티 라이브러리의 제약이 없습니다. 쓰레드 사용 가능쓰레드가 사용가능했습니다. 다만 요청을 완료하기 전까지만 사용할 수 있습니다. ndb 라이브러리의 퇴장기존에 datastore를 사용할 때 사용했던 ndb를 사용하지 못하고 google-cloud-datastore 라이브러리를 사용해야 합니다. 로깅 방식의 변경기존 런타임에서는 logging을 사용하면 바로 스택드라이버에서 사용할 수 있었지만, 새 런타임에서는 명시적으로 스택드라이버를 import 시켜서 로깅해야 합니다. 기존처럼 logging.info, logging.error 찍어도 로그에서 확인할 수 없습니다. integrated 된 서비스 사용 불가이 부분이 기존 flexible environment 비슷하게 되었습니다. 파이썬2 Standard environment와 긴밀하게 연결되어 있던 Mail, Search, memcache, Search, Task Queue를 사용할 수 없습니다. 다른 서비스를 사용해야 합니다. local 개발 환경 변경기존의 dev_appserver를 사용할 필요가 없습니다. 대신 개발 시 기존 SDK에서 제공하는 기능은 로컬 에뮬레이터를 사용해야 합니다. URL Fetch out, Requests In기존에는 앱 엔진 외부 Request는 URL Fetch를 사용해야 했으나 다른 앱처럼 Requests 라이브러리를 사용하세요~ 대략적인건 이 정도 인듯 합니다. : ) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/12/29/google-app-engine-python3-pros-cons/"},{"title":"구글 앱 엔진 소개","text":"구글 앱 엔진(Google App Engine)은 구글 클라우드 플랫폼에서 구동되는 웹 프레임워크입니다. HTTP/HTTPS 요청을 처리하는 서비스로서 아마존 웹서비스(이하 AWS)의 Beanstalk와 유사합니다. 하지만 이 둘 사이에는 결정적인 차이가 있습니다. 구글 앱 엔진은 완전 관리형(Fully managed) 서비스, AWS는 일부 관리형 서비스라는 점이죠. 쓸만한가요?근무하고 있는 곳에서는 REST API를 구글 앱 엔진에 올려서 사용하고 있으며, 하루에 수 백 ~ 수 천만건의 요청을 처리하고 있는 중입니다. 일하는 기간 동안에 구글 앱 엔진에서 문제가 발생한 적은 없었습니다. 장애는 주로 DB쪽이나 다른 모듈에서 문제가 발생해서 생긴 적이 대부분이었습니다. 구글 앱 엔진의 장점쉽고 간단하다같은 서비스를 EC2를 사용해 구축한다고 하면 Elastic Load Balancer + Auto Scaling Group + EC2 + Route53 설정 등을 해줘야하고 추가적으로 배포도 신경 써줘야 하며, 앱이 죽었는지 살았는지 Health Check도 필요합니다. 하지만 구글 앱 엔진은 이런게 필요없습니다. Load Balancer와 Scaling 설정은 스스로 혹은 간단한 옵션으로 관리하며 인스턴스가 죽으면 자동으로 해당 인스턴스를 자동으로 재시작합니다. 무중단 서비스는 기본이다내부적으로 Blue Green Deployment를 구현, 새로운 앱을 배포하면 앱 엔진 내부에서 새로운 앱을 배포 후 라우팅을 새로운 앱으로 돌립니다. 강력한 HTTP URL기반 라우팅개인적으로 매우 마음에 드는 기능입니다. 태그에 의존하는 AWS과는 달리 구글 클라우드는 프로젝트 이름 단위로 리소스가 확실히 구분됩니다. 구글 클라우드에서 example 이라는 프로젝트를 만들었으면 앱 엔진의 URL주소는 https://example.appspot.com이 됩니다. 배포용은 가만히 냅두고 개발용으로 별도의 인스턴스를 만들어서 사용하고 싶을 경우에는 개발용 버전(예: staging)을 배포하면서 이 인스턴스에 트래픽을 주지말라는 옵션을 줍니다. 그리고 개발용 인스턴스에 요청을 보내고 응답을 받고 싶을때는 그냥 https://staging-dot-example.appspot.com 이라고 호출하면 자동으로 개발용 버전으로 해당 트래픽을 연결합니다. 안쓰면 0원 &amp; 지속적으로 사용하면 최대 30% 할인별도 옵션을 두지 않을 경우 일정 시간동안 요청이 없으면 Instance 갯수가 0이 됩니다. 즉 과금이 없습니다. 펫 프로젝트 할 때 제격이죠. 또한 지속적으로 인스턴스를 켜두면 알아서 30% 정도 깎아줍니다. AWS처럼 스팟 인스턴스니 뭐니 하면서 요금에 신경을 조금 덜 써도 됩니다. 구글 앱 엔진의 단점한국 리전이 없다AWS와는 달리 구글 앱 엔진은 한국 리전이 없습니다. 당분간 제일 가까운 리전은 도쿄 리전인데 보통 30 ~ 50ms 정도 Latency를 보입니다. 보통 AWS 서울 리전은 10 ~ 20ms 의 Latency를 보이는 것에 비해서 약간 느린 편이죠. 언어 및 언어 버전에 제약이 있다지원하는 언어는 Python, Java, PHP, Go 뿐입니다. 아니 구글 앱 엔진 문서에는 C#, Node.js 도 적혀있는데 왜 이러시냐고 묻으실 분들은 아래 조금만 더 읽어주시면 됩니다 : ) 프레임워크와 궁합이 좋지 않다구글 앱 엔진은 완전 관리형 시스템인 PaaS 서비스다보니까, 제약이 상당히 많습니다. Go 언어의 예를 들죠. 일반적인 Go 어플리케이션의 Main은 아래와 같은 형태를 띕니다. 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, handle) log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))}func handle(w http.ResponseWriter, r *http.Request) { if r.URL.Path != &quot;/&quot; { http.NotFound(w, r) return } fmt.Fprint(w, &quot;Hello world!&quot;)} 하지만 구글 앱 엔진의 Main의 형태는 아래와 같습니다. 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;net/http&quot; &quot;google.golang.org/appengine&quot;)func main() { http.HandleFunc(&quot;/&quot;, handle) appengine.Main()}func handle(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &quot;Hello, world!&quot;)} 뭐가 다른지 아시겠나요? 웹 어플리케이션은 라우팅 설정을 한 후 특정 포트를 Listen 상태로 들어가는데 앱 엔진에는 이 부분이 없습니다. 따라서 모든 부분을 관리하는 모노리스 웹 프레임워크 중 일부는 웹 엔진에서 제대로 구동이 안될 수 있습니다. 장고(Django) 도 초반에는 앱 엔진에서 제대로 돌릴 수 없었고 Go 언어의 Revel 역시 앱 엔진에서 돌릴 수 없습니다. Flexible Environment 의 최소 비용이 비싸다여기서 앞에서 언급한 단점인 ‘언어에 제약이 있다’에 대해서 설명할 수 있습니다. 구글 앱 엔진에서는 Standard Environment(이하 SE)와 Flexible Environment(이하 FE)가 있습니다. 이 둘의 결정적인 차이는 SE는 샌드박스 환경에서 실행되고 FE는 AWS의 EC2와 같은 가상 컴퓨팅 머신 위에서 실행된다는 차이입니다. 따라서 FE는 웹 프레임워크의 제약이 없고 언어의 제약도 많이 없지만 SE는 샌드박스 상에서 돌아갈 수 있는 런타임 위에서만 구동됩니다. 예를 들어 Python 3.x가 십 수년전부터 존재함에도 불구하고 SE상에서는 Python 2.7만 지원하며, PHP7이 나왔음에도 SE에서는 PHP5.5만 지원하지요. SE는 인스턴스 시간당 비용으로 과금되지만 FE는 CPU, Memory, 디스크 용량의 사용량으로 과금한다는 점이 다릅니다. 암튼 EC2와 같은 가상 컴퓨팅 환경에서 돌아가는게 FE라고 했는데 가장 싼 CPU 타입으로 해도 월 $40을 피할 수는 없습니다. 이는 EC2의 가장 저렴한 인스턴스 타입인 t2.micro가 $8.5에 비한다면 매우 비쌉니다. 개인적으로 이 부분이 가장 아쉬운 부분입니다. SE와 FE의 차이에 대한 글 : https://cloud.google.com/appengine/docs/the-appengine-environments document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/04/22/introduce-google-cloud-app-engine-1/"},{"title":"Vue 패키지 개발하기","text":"작년 말부터 하고 싶었지만 시간이 안나서 못했던 일 - 바로 공식 npm 저장소에 내 라이브러리를 올릴 일이었다. 작년 하반기에는 vue.js + Typescript 로 웹 페이지를 개발하고 있었는데, 그 프로젝트에서 견적서의 금액을 한글로 바꾸는 부분을 꼭 npm에 올리고 싶었다. 그래서 결국 만들어 올렸다. 한 3~4시간 걸린듯하다. 이 패키지가 할 수 있는 일은 숫자를 한글로 변환해준다. 예를 들어 100,1000원은 ‘일백만일천원’ 이런식으로 견적서에서 사용할 수 있는 한글로 변환한다. 이 글은 해당 패키지를 만들고 퍼블리싱까지 한 일을 정리해서 올렸다. 해당 패키지는 vue-cli와 타입스크립트를 써서 만들었다. 워낙 간단한 라이브러리라 타입스크립트는 안써도 된다. 12npm install -g @vue/clivue create my-lib @vue/cli는 create-react-app 과 같이 vue 앱의 스켈레톤을 만들어주는 패키지다. 만들어진 디렉토리로 들어가서 앱을 실행해본다. 12cd my-libnpm run serve 뷰 기본 앱을 볼 수 있다. 모듈(컴포넌트, 필터) 패키징화/[project-root]/src 에 filters 디렉토리를 만든다. 그 후 index.ts에 아래의 코드를 작성했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import Vue from &apos;vue&apos;;/** * 숫자를 한글로 변환한다. * @param value Filter 값으로 넘어온 숫자 * @param priceMode true면 변환된 한글에 &apos;일&apos;이 붙는다. 예를 들어 &apos;일십이만삼천원&apos;과 같이 주로 금액을 표시할때 사용한다. * false라면 &apos;일&apos;이 생략된다. 다만 억과 같이 단독으로 사용했을때 어색한 숫자는 앞에 &apos;일&apos;을 붙인다. * @returns 한글로 변환된 숫자를 리턴한다. 만약 숫자가 아니거나, 범위를 초과하거나 기타 문제가 발생했을 경우 빈 문자열을 리턴한다. */export function numToKr(value: number, priceMode = true): string { if (value === 0) { return &apos;영&apos;; } else if (value === 1) { return &apos;일&apos;; } const han1 = [&apos;&apos;, &apos;일&apos;, &apos;이&apos;, &apos;삼&apos;, &apos;사&apos;, &apos;오&apos;, &apos;육&apos;, &apos;칠&apos;, &apos;팔&apos;, &apos;구&apos;]; const han2 = [&apos;&apos;, &apos;만&apos;, &apos;억&apos;, &apos;조&apos;, &apos;경&apos;, &apos;해&apos;]; const han3 = [&apos;&apos;, &apos;십&apos;, &apos;백&apos;, &apos;천&apos;]; if (!priceMode) { // 1만 들어올 경우 문제가 생긴다. if (value !== 1) { han1[1] = &apos;&apos;; } } const numStr = value.toString(); const size = numStr.length; if (size &gt; 4 * han2.length) { return &apos;&apos;; } let kor = &apos;&apos;; let tmp: string[] = []; for (let i = 1; i &lt; numStr.length + 1; i++) { const v1 = Number.parseInt(numStr.charAt(i - 1), 10); if (isNaN(v1)) { break; } if (v1 !== 0) { tmp.push(han1[v1]); tmp.push(han3[(size - i) % 4]); } if ((size - i) % 4 === 0 &amp;&amp; tmp.length !== 0) { // 일억과 같이 일을 생략하면 어색한 숫자는 &apos;일&apos;을 붙여준다. kor += tmp.join(&apos;&apos;); if (tmp.length === 2 &amp;&amp; v1 === 1 &amp;&amp; !priceMode) { kor += &apos;일&apos;; } tmp = []; kor += han2[(size - i) / 4]; } } return kor;}/** * 숫자로 된 금액을 한글로 변환한다. * 예) 994950 -&gt; 구십구만사천구백오십원 */function install() { Vue.filter(&apos;numberToKor&apos;, numToKr);}export default install; 해당 모듈은 단순하게 main.ts 혹은 main.js에서 아래와 같이 사용하면 된다. 123import NumberToKorFilter from &apos;vue-number-to-kor&apos;; Vue.use(NumberToKorFilter); 1. 라이브러리 빌드 셋업먼저 해당 모듈을 타겟으로 잡고 빌드한다. vue-cli를 설치하면 내부적으로 vue-cli-service 를 사용하는데, 이 패키지를 이용하여 해당 모듈을 빌드한다. 기존 package.json은 아래와 같은 형태일 것이다. 123456&quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;test&quot;: &quot;vue-cli-service test:unit&quot;} 여기에 번들링할 명령어 - build:bundle을 추가한다.1234567&quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:bundle&quot;: &quot;vue-cli-service build --target lib --name vue-number-to-kor ./src/filters/index.ts&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;test&quot;: &quot;vue-cli-service test:unit&quot; }, 2. npm run build:bundle위 명렁어 실행을 마치면 dist 디렉토리에 umd와 commonjs 용 자바스크립트 라이브러리가 번들링되어 있을 것이다. 3. package.json에 name설정 및 main과 files 추가이 부분이 중요한데, 반드시 package.json에 main 프로퍼티를 추가해야 한다. umd와 commonjs 중 하나를 선택하면 된다. 123{ &quot;main&quot;: &quot;./dist/vue-number-to-kor.common.js&quot;} 그리고 어떤 파일을 패키지에 넣을 것인지 npm에 알려줘야 한다. 이를 package.json에 추가한다. 123456789{ &quot;files&quot;: [ &quot;dist/*&quot;, &quot;src/*&quot;, &quot;public/*&quot;, &quot;*.json&quot;, &quot;*.js&quot; ],} package.json에 name 속성이 있다. 이게 npm 공식 저장소의 패키지 이름이 되니까 신중하게 결정하도록 한다. 물론 겹치지 않는 걸로 한다. 123{ &quot;name&quot;: &quot;패키지 이름&quot;,} 4. npm 로그인npm 공식 저장소에 패키지를 퍼블리싱 하려면 물론 npm에 회원 가입이 되어 있어야 한다. 계정이 없으면 먼저 회원가입을 하자. 그리고 npm login 명령어를 통해서 해당 계정으로 로그인한다. 로그인 상태 확인은 npm whoami를 통해서 할 수 있다. 5. 빌드 및 퍼블리싱퍼블리싱 전 중간에 코드를 바꾸지 않았으면 다시 빌드 하지 않아도 되지만, 얼마 걸리지 않으니까 그냥 확실하게 빌드 다시 하자.1npm run build:bundle 그 다음 npm 공식 저장소에 퍼블리싱을 한다. 1npm publish --access public 다음 npm공식 저장소에서 해당 패키지가 잘 퍼블리싱 되었는지 확인한다. 이걸로 끝이다. 기타package.json에는 상당히 많은 정보를 담아야 한다. 기왕 패키지를 배포하는거 다른 개발자가 많이 쓰면 기분이 좋지 않은가. 반드시 기입하기를 권장하는 정보는 version, license, homepage 이며, 넣으면 좋은 정보는 author, keywords, bugs가 있다. 아래는 예시 package.json이다.1234567891011121314151617181920{ &quot;version&quot;: &quot;0.1.1&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;keywords&quot;: [ &quot;vue&quot;, &quot;vuejs&quot;, &quot;vue-number-to-kor&quot;, &quot;한글&quot;, &quot;숫자 변환&quot;, &quot;filter&quot; ], &quot;author&quot;: { &quot;name&quot;: &quot;Jongha Kim&quot;, &quot;email&quot;: &quot;kim.jongha@gmail.com&quot; }, &quot;bugs&quot;: { &quot;url&quot;: &quot;https://github.com/wisedog/vue-number-to-kor/issues&quot; }, &quot;homepage&quot;: &quot;https://github.com/wisedog/vue-number-to-kor&quot;,} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/02/04/publish-vue-package/"},{"title":"에이팀벤쳐스 (개발팀)에 대한 오해","text":"잡 플래닛에 올라온 에이팀벤쳐스에 대한 안좋은 글이 있다. 열정페이 관련 누가 올렸는지는 모르지만 적어도 개발팀에는 이런 문화가 없다고 자신있게 말할 수 있다. 내가 알기론 다른 팀도 크게 다르지는 않다. 현재 개발팀은 스크럼 방식으로 일하고 있고, 주말근무 안 한지는 1년이 넘었고 야근한 기억도 가물가물하다. 도리어 시니어 개발자로서 늦은 면접에 참여하고 나오면 주니어 개발자들이 몽땅 퇴근해서 배신감이 들 정도니까. 열정페이 이딴거 하나도 없고 2019년 3월에 개발팀이 새로 꾸려진 이후로는 들어온 사람이 훨씬 많다. 임원 또 하나의 단점으로 지적된 임원의 수는 솔직히 잘 모르겠다. 같은 공간에서 일하는 사내 이사 2명이 있긴한데, 실제로 등록된 임원이 몇이나 되는지는 잘 모르겠다. 아마 사외이사가 아닐까? 나 조차 모를 정도면 뭐 그닥 영향력이 없다는 반증이 되겠다. 그리고 사내 이사 2명도 굉장히 훌륭하신 분들이라 존경과 감사를 담아 일을 했던 기억이 난다. 무조건 열심히 해라, 보상은 나중에 처음 들어보는 얘기다. 언급할 가치가 없다. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/02/27/에이팀벤쳐스-개발팀에-대한-오해/"},{"title":"코딜리티(Codility) 첫 경험 - 데모 문제 1번","text":"개인적으로 코딩테스트에 대한 공포감(?)이 조금 있다. 사실 코딩테스트에 대해서는 논쟁이 많은 편이다. 개인적으로 코딩테스트는 그냥 최소한의 자격 요건을 보는거지 이 결과로 당락을 결정하는건 아니라고 보는 편이다. 운동하는 사람들끼리 통용되는 말인 노가다에서 쓰는 근육과 헬스에서 쓰는 근육이 다르다이 프로그래밍 세계에서도 그대로 통용된다. 실무에서 쓰는 근육과 코딩테스트에서 쓰는 근육이 다르다 - 즉 코딩테스트 잘본다고 해서 실무를 잘하는게 아니다. 프로그래머라면 물론 코딩도 잘해야 하지만 직급에 맞는 시야와 상호간 커뮤니케이션 능력, 품질에 대한 고려 등등 코딩 외적인 능력이 있어야 훌륭한 개발자가 될 수 있다는게 내 생각이다. 아 근육 얘기 나오니까 하는 얘긴데 코딩테스트 본지 오래된 사람 갑자기 불러다가 코딩테스트 시키면 아무리 천하의 구글러라도 원하는 점수를 못얻을거다. 쓰는 근육이 다르니까. 암튼 말이 길어졌는데 코딩테스트에 대한 공포감을 해결하고자 코딜리티라는걸 이번에 처음 접해보고 한 번 도전해보았다. 코딜리티에는 데모 문제가 있는데 첫 번째 문제인 바이너리 갭(Binary Gap)을 한 번 풀어보았다. 이 문제는 함수를 짜는데 이진수 1과 1 사이에 있는 최대 0의 갯수를 구하는 문제다. 예를 들어 529는 이진수로 1000010001 이며, 함수는 4를 리턴한다. 9는 이진수로 1001이며 함수를 2를 리턴한다. 다만 32는 1000000 이라 갭이 없으므로 0을 리턴하게 된다. 처음에는 뭔가 이진수로 변환한 스트링을 순회하면서 Candidate를 배열에 추가하고 등등등 생각하다가 생각하다가…갑자기 번뜩이는 split() 함수! 이걸 사용하면 굉장히 쉽게 문제를 해결 -ㅅ-;;;뭔가 개꼼수 같지만 동작은 잘한다. 테스트케이스 몽땅 통과. 아래 코드는 3분만에 적었다. 알고리즘을 신성시하고 뭔가 대단한걸 기대한 사람들은 날더러 비정통파, 넌 프로그래머도 아냐라고 욕할지도 몰라. 12345678910111213141516171819202122function solution(N) { // write your code in JavaScript (Node.js 8.9.4) if (N === undefined || N &lt; 0) { throw new Error(&apos;invalid input&apos;); } // 10진수를 2진수로 const bin = N.toString(2); // 1을 delimeter로 쪼갠다. const sp = bin.split(&apos;1&apos;); // 이진수 마지막이 0이면 배열의 마지막을 뺀다. if (bin.endsWith(&apos;0&apos;)) { sp.splice(sp.length - 1, 1); } const lens = sp.map((v) =&gt; { return v.length; }); return Math.max(...lens);} 물론 이건 1번 문제니까 쉽겠지. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/08/03/코딜리티-Codility-첫-경험-데모-문제-1번/"},{"title":"같은 VPC인데도 EKS에서 RDS 연결 안될 경우","text":"AWS의 Kubernetes 서비스인 EKS를 구성할때 겪었던 일이다.EKS와 RDS를 같은 VPC 안에 두었음에도 불구하고 EKS에서 RDS로 연결이 되지 않고 계속해서 타임아웃에러만 발생했다. 이 경우 먼저 Pod에서 RDS 주소를 인지하는지 먼저 확인했다.먼저 Pod 이름 먼저 확인 1$ kubectl get all -n shipda 파드 이름이 pod/shipda-api-v2-79d868d65-2kh4t 이라 한다면 pod에다 nslookup 명령어를 실행시킨다. 1234567891011$ kubectl exec -it pod/shipda-api-v2-79d868d65-2kh4t -n shipda nslookup &lt;blahblah&gt;.rds.amazonaws.comServer: 10.100.0.10Address: 10.100.0.10:53Non-authoritative answer:&lt;blahblah&gt;.rds.amazonaws.com canonical name = &lt;blahblah&gt;.ap-northeast-2.compute.amazonaws.comName: &lt;blahblah&gt;.ap-northeast-2.compute.amazonaws.comAddress: 111.111.111.111Non-authoritative answer:&lt;blahblah&gt;.rds.amazonaws.com canonical name = &lt;blahblah&gt;.ap-northeast-2.compute.amazonaws.com DNS 를 리졸빙 하는걸로 봐서는 DNS는 문제 없는것 같다. 그러면 실제로 접속이 되는지 핑을 날려본다.1$ kubectl exec -it pod/shipda-api-v2-79d868d65-2kh4t -n shipda ping &lt;blahblah&gt;.rds.amazonaws.com 핑이 가지 않았다. 해결 방법을 한참 찾았다. 같은 VPC라서 문제 없을 줄 알았는데 뒤통수 맞은 기분이었다. 사실 프로덕션으로 GCP와 Azure는 썼었는데 AWS는 처음이라 좀 더 헤맸을수도 있다. 사실 요즘 클라우드가 다들 엇비슷해서 있을거 (거의) 있어서 적응에는 큰 문제는 없지만 아마존 같은 경우엔 VPC, Security Group, Subnet, RoutingTable 등을 좀 더 세밀하게 지정해야 하기 때문에 헤맸을 수도 있다. 결국 해결책은 - RDS의 시큐리티 그룹에 EKS의 시큐리티 그룹을 넣어주면 해결되는 일이었다. 뭔가 굉장히 허탈하다. 참고로 다른 VPC라면 VPC 피어링을 사용하면 된다. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/13/같은-VPC인데도-EKS에서-RDS-연결-안될-경우/"},{"title":"타입스크립트 전면 도입기","text":"회사 개발팀에 사정이 있어서 지난 3월 말부터 개발팀을 이끌게 되었다. 첫 번째 임무는 기존 백엔드의 C#, CQRS, Event-Sourcing, DDD를 걷어내는 일이었다. 좋은 디자인 패턴과 개발방법론과 언어긴 하지만 현 개발팀 아니 한국에서는 좀 쉽지 않은 결정이다. 이유는 많지만 한 마디로 얘기하자면 현 개발팀에 안맞는 옷이었다. 2020.12 첨언이렇게 적고나니 DDD가 한국 실정과 안맞는게 아니냐고 하는 오해가 있어서 추가적으로 적자면 C#이 한국에서는 쉽지 않은 결정이고, DDD(CQRS, Event-Sourcing과 세트)는 개발팀 몸에 맞지 않는 옷이었다. 제일 큰 이유는 C#, 정확히는 .Net Core 개발자를 못구해서였다. DDD는 좋은 아키텍쳐지만 도메인 전문가의 유무, 프로젝트의 성격, 개발팀의 실력에 따라서 그 결과가 불투명하다. 다만 도메인이 복잡할 경우나 대규모 개발팀 운영에는 DDD가 강력한 아키텍쳐다. 변화가 생긴 개발팀은 Javascript 기반 프론트 1명, 풀스택 2명이었고 C#/Java Entry Level 1명 그리고 나까지 5명이었다. 마음 먹은대로 하자면 백엔드는 Python 혹은 Go로 하고 싶었지만 작은 회사일수록 테크 스택을 통일해야 한다는게 나의 지론이기 때문에 백엔드는 Express를 도입하기로 했다. Express 도입과 함께 한 가지 도입한 테크 스택은 Typescript다. 현재 웹 프론트엔드인 vue.js와 백오피스 프론트엔드인 react.js는 이미 Typescript였다. 이 참에 Express도 Typescript를 도입하기로 했고 최종적으로 Typescript Rest을 선택했다. 프론트엔드와 백엔드를 모두 Typescript로 통일하고 그 장점을 극대화 하기 위해서 양쪽 사이의 API에서 사용하는 인터페이스나 Enum을 모아놓은 프로젝트를 만들었다. 예를 들어 Item 정보를 만드는 POST API가 있다고 가정하자. 123456789101112131415161718import { POST, Path } from &apos;typescript-rest&apos;;interface ItemBody { name: string; quantity: number;}@Path(&apos;/item&apos;)export class ItemController { /** * 아이템을 만든다. */ @Path(&apos;&apos;) @POST public postItem(body: ItemBody){ // ..... }} 그리고 프론트엔드에서 axios.js로 해당 API를 쓴다면 아래와 같겠다. 12345678910111213141516interface ItemBody { name: string; quantity: number;}//// 생략class APIs { public async doSend(item: ItemBody) { try { await axios.post(`${BASE_URL}/item`, item); } catch (e) { // .... } }}//// 후략 두 프로젝트에서 공통으로 쓰는 인터페이스인 ItemBody를 별도의 프로젝트로 분리, Private NPM 저장소를 만들고 이걸 import를 한다. 1234567891011121314151617181920import { POST, Path } from &apos;typescript-rest&apos;;import { ItemBody } from &apos;@mycompany/interface&apos;;/* 이 부분을 없앨 수 있다.interface ItemBody { name: string; quantity: number;}*/@Path(&apos;/item&apos;)export class ItemController { /** * 아이템을 만든다. */ @Path(&apos;&apos;) @POST public postItem(body: ItemBody){ // ..... }} 123456789101112131415161718import { ItemBody } from &apos;@mycompany/interface&apos;;/* 아래 코드를 없앨 수 있다.interface ItemBody { name: string; quantity: number;}*///// 생략class APIs { public async doSend(item: ItemBody) { try { await axios.post(`${BASE_URL}/item`, item); } catch (e) { // .... } }}//// 후략 여기서는 프로퍼티가 단순히 2개인 인터페이스만 대상으로 했지만, 프로퍼티가 많아질 수록, 그 인터페이스가 많아질 수록 강력한 효과를 발휘했다. 프론트엔드에서 힘들게 Swagger를 보고 인터페이스를 정의할 필요가 없었고,만들다가 생기는 휴먼 에러도 방지할 수 있었다. 단순히 npm을 업데이트함으로서 API와 싱크를 맞추기도 쉬웠다. 무엇보다 각각의 프로젝트에서 각각 관리하던 인터페이스 코드를 통합관리 할 수 있어서 굉장히 생산성이 높아졌다. 필요성을 느껴서 만들었기 때문에 다른 프로젝트에서는 이렇게 쓰는지는 잘 모르겠지만 프론트엔드와 백엔드 모두 타입스크립트를 쓴다면 한 번 도입해보면 좋겠다. P.S 두 달 반만에 성공적으로 C#에서 자바스크립트로 이전했다. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/06/18/타입스크립트-전면-도입기/"},{"title":"외주 레거시로부터의 여정 2편 - 개발팀 구성","text":"팀 꾸리기소프트웨어 개발은 혼자 할 수 없다. 더욱이 8~9개월 가까이 외주에서 진행된 프로젝트를 이어 받아야 하는 입장에서는 더더욱 그렇다. 이런 초창기 개발팀일수록 2인자 테크 리더의 역할이 굉장히 크다. 2인자는 나의 오른팔로서 내가 모자란 부분을 채워주고 때에 따라서는 적어도 2~3명의 개발자를 매니징 할 수 있을 인재여야 한다. 경험상 보통 3~4년차 개발자부터 이 역할을 맡을 수 있다. 나는 연차나 학력으로 개발자를 평가하지 않는다. 1년 차 고졸 개발자라도 굉장히 실력이 좋은 경우도 드물지만 존재하며, 20년차 개발자라도 과거의 영광에 사로잡혀 구닥다리 방식대로만 일을 하는 사람도 있다. 다만 짬밥(?)을 무시하지 못하는게 보통 3~4년차 개발자는 평균적으로 어느 정도의 기술적인 기반을 다져놨기 때문에 내가 원하는 2인자 - 테크 리더일 가능성이 굉장히 높았다. 문제는 이 3~4년차 개발자들이 시장에서 가장 잘팔리고, 가장 자만심이 높을때라 이렇게 듣보잡(분하지만 지금은 그렇다…) 스타트업에 지원할 가능성이 굉장히 낮다. 이 분들은 주로 한 회사에서 주니어 개발자로 경력을 쌓고 그 다음 회사로 배민이나 토스, 네이버, 카카오같은 테크 대기업에 지원하고 있으리라. 혹시나 하는 마음에 개발자 구합니다 - 라고 로켓펀치에 올렸으나 결과는 대실패였다. 외국인 개발자 한 분만이 지원했을 뿐 아무도 지원하지 않았다. 게다가 개발자들에게 생소한 “물류” 분야의 스타트업이라 더더욱 힘들었다. 예를 들어 킥보드 스타트업이다 한다면 개발자들도 대충 뭔지는 안다. 도심을 활보하는 킥보드를 타본 적은 없을지언정 뭔지는 알고 있다. 실버 케어 스타트업이다 한다면 개발자들도 대충 뭔지는 안다. 다들 할아버지 할머니가 있거나 있었거나 없어도 뉴스 등을 통해서 간접적으로 접했을테니까. 근데 택배도 아니고 수출입물류입니다 - 인코텀즈 아세요? 20피트 드라이는요? 그럼 급정색하고 “안녕히계세요” 이러고 집에 갈거다. 여기서 내가 취할 수 있는 선택지는 단 2개였다. 오른팔이 될 수 있는 3~4년차 개발자를 계속 찾는다. 주니어를 뽑아서 멱살잡아 끌고가서라도 중니어로 만든다. 1번이 이루어지면 확실하게 개발팀에 큰 힘이 된다. 다만 “언제”라는 측면에서 불확실성이 매우 컸다.2번 - 주니어 채용은 확실히 쉽다. 다만 주니어 특성상 똥인지 된장인지는 겪어봐야 알고 소프트웨어 개발자로서의 성공 의지에 따라서 발전 속도의 차이가 너무 심하다. 그리고 멱살잡고 끌고가는 사람도 보통 힘든게 아니다. 결국 나는 2번을 택하기로 했다. 모든 비즈니스에서는 ‘시간’이 매우 중요하다. 전설 속의 유니콘과 같이 언제 올지 모르는 테크 리더급 개발자 채용을 기다리다가 개발을 그르칠 수 있었다. 개인적으로 불확실한 최선보다는 확실한 차선을 선호한다. 게다가 Node.js 백엔드, AWS 인프라 정도는 나 혼자 할 수 있고 리액트도 다시 공부하면 되긴 된다. 근데 이놈의 리액트는 잠깐 손놨더니 최신 코드는 죄다 React Hooks 일세? 내가 상대적으로 모자란 부분인 프론트엔드 (특히 스타일링)쪽을 강화시켜줄 개발자가 절실했지만, 어쩔 수 없이 지금 현재 주니어 프론트엔드 개발자와 백엔드 인턴으로 팀을 만들었다. 그리고 이 어린 동료들은 입사하자마자 불행히도 벌써부터 공부거리를 받고 4월 말까지 검사를 받아야 한다. 인턴에게는 인터넷 기본(HTTP, Cookie, Session)에 대한 발표를 주니어 프론트엔드 개발자에게는 DNS(호스팅, DNS, 도메인네임, google.com을 쳤을 때 뒷단에서 벌어지는 흐름)관련 내용을 공부해오라고 했다. 참고로 앞으로 공부할 커리큘럼도 짜놨다. HTML, CSS, Javascript(쪽은 좀 더 세분화), Git 심화(PR, Merge, Rebase, Cherrypick), 보안, 주석, CSS 레이아웃(Flex, 반응형, Styled Component), 테스팅, Database, OS, 자료구조, 인증, CI/CD, 개발/설계, 아키텍쳐 패턴, 도커 그 외 Devops 관련된 모든 사항이다. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/19/외주-레거시로부터의-여정-2편/"},{"title":"외주 레거시로부터의 여정 3편 - API 개편","text":"백엔드 개편API외주 개발사가 개발한 API는 그야말로 순수한 Express에 자체 미들웨어로 중무장한 상태였다. 겉으로 포장만 안했지 일종의 외주사 전용 프레임워크라고 해도 무방했다. 그런데 말입니다. 유닛 테스트가 없다 테스트가 없으니 물론 커버리지도 0%였다. 테스트가 없는 여파는 내가 합류한 3월부터 슬슬 찾아오기 시작했다. 초반에는 비즈니스 검증 때문에 기능이 수시로 변한다. 대표가 외주에게 몇 번 변경을 요청했는데 여지없이 잔버그가 우수수 떨어지기 시작했다. 고민의 시간이 찾아왔다. 여기다가 유닛테스트를 붙일 것인가. 근데 코드를 보니 컨트롤러에 비즈니스 로직이 잔뜩 있어서 supertest로 API테스트를 붙여야만 테스트 커버리지를 올릴 수 있었다. 게다가 타입이 없는 동적언어인 자바스크립트 특성 상 커버리지를 90%정도까지는 올려야 안정적으로 돌아갈 수 있었다. 게다가 비즈니스 로직이 생각보다 복잡했다. 테이블 70개가 괜히 생긴게 아니었다. 컨테이너 종류만도 17가지 종류나 되었고 국가 간의 무역거래조건인 인코텀즈만 해도 10종류가 넘었다. 게다가 컨테이너, 인코텀즈 외에도 수 없이 많은 요소가 있었고 각 요소마다 처리하는 로직도 다 달랐기 때문에 발을 살짝만 잘못 디뎌도 순식간에 골로가는 아주 좋은(?) 조건이었다. 타입스크립트 도입여기서의 결심은 타입스크립트 도입이었다. 그렇다고 전면 재개발은 아니었다. 나는 넷스케이프의 전철을 밟을 생각이 전혀 없었다. 다행히 개발된 코드가 ES6라서 코드 복붙 70% 정도로 API를 구성할 수 있을 것 같았고, 실제로도 그러했다. 타입스크립트 도입 시 NestJS를 비롯한 각종 타입스크립트 프레임워크를 좀 물색했는데, 최종적으로 Typescript-rest를 도입하기로 하였다. 가장 큰 이유는 나에게 주어진 시간이 많지가 않았기 때문에 바로 실전 투입할 수 있는 프레임워크여야 했다. Typescript-rest는 전 회사에서도 써서 러닝커브가 없었고 무엇보다 NestJS처럼 특정 구조를 강제하지도 않았다. NestJS가 틀에 박힌 노드판 스프링이라면 Typescript-rest는 그나마 Express에 가까운 친구였다. 소스코드를 옮기는건 힘들었지만 꽤나 재미있는 작업이었다. 보통 아래와 같이 작업을 했다. Typescript-rest에서 API 컨트롤러를 만들고 여기에 기존 소스코드를 그대로 붙인다. 물론 타입이 없기 때문에 그대로 붙지는 않는다. 한 번 붙일때마다 VSCode 화면은 공산혁명이라도 일어난듯이 온통 빨간줄이 쫙쫙 그어지곤 했다. 대부분은 타입 문제였고 일부만 코드 문제였다. 타입이 없으면 일단 any로 메꾸고 number, string, boolean 같은 Primitive 타입만 대체하는 방향으로 컨트롤러 내 API를 구성했다. API 만들때 당연히 모델도 필요했다. API 만들때마다 모델을 몇 개씩 만들기도 했다. 컨트롤러에서 비즈니스 로직을 떼어낸다. Service를 만들고 컨트롤러에 DI(Dependency Injection)했다. 최종적으로 컨트롤러에서는 Request, Response, Validation에 대한 책임만 지고, 비즈니스 로직은 서비스에서 담당하게 된다. 서비스를 상대로 유닛 테스트를 만든다. 이렇게 해서 한 달만에 거의 대부분의 소스코드를 옮겼고 커버리지도 70% 이상을 달성했다. 여기에는 우리 인턴님의 지대하신 공헌이 있었다. : &gt; 그 외 Pub/Sub 모델 도입, Notification, Scheduling 등의 주제는 별도의 포스트를 통해서 소개하도록 하겠다. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/25/외주-레거시로부터의-여정-3편/"},{"title":"외주 레거시로부터의 여정 1편 - 기존 레가시 파악","text":"시작2020년 1월 중순, 서울시 광화문의 어느 술집에서 남자 셋이서 술을 마시고 있었다. 셋은 기분이 좋은지 상 위의 안주는 거들떠보지도 않은 체, 술만 마시고 있었다. 두 사람은 좀 더 나이들어 보이는 어떤 남자에게 연거푸 고맙다는 인사와 함께 계속 잔을 부딪혔다. 이렇게 좀 더 나이많은 남자는 셀러노트 CTO가 되었다. 그리고 그 남자는 3월 중순에 본격적으로 판도라의 상자를 여는데… 심심해서 도입부를 소설 형태로 적어보았다. 아내가 봤으면 무슨 똥글이냐고 욕했겠지만 마침 몇 시간동안 자리를 비운지라 거침없이 글을 쓴다 : &gt; 암튼 그 판도라의 상자를 여는 남자는 바로 나, 자신이다. 첫 임무는 외주사가 개발하고 있는 셀러노트의 물류 플랫폼 서비스 쉽다를 자체개발로 돌리는 일이었다. 외주는 다행히 PHP로 개발하지 않고 node.js 로 개발을 했다. 아마 PHP로 했었으면 CTO 자리를 정중히 거절했을거다. PHP자체가 나쁜건 아니다. 아니 아직까지 PHP 5.x로 개발했다면 그건 나쁘다고 단언할 수 있다. 허나 PHP도 7부터는 속도도 어느정도 빨라지고 상당히 괜찮은 물건이 된건 알고 있으나, $투성이인 코드가 싫다는 말도 안되는 핑계로 PHP를 거부하고 있고 앞으로도 사용하지 않을 예정이다. 4월 13일부로 입사한지 1달이 지났다. 지난 1달 간은 레거시를 바탕으로 좀 더 나은 시스템으로 만드는 과정의 연속이었다. 이를 회고 겸 경험 공유 차원에서 시리즈로 연재할 예정이다. 진짜 시작입사는 3월이지만 소스 코드와 AWS는 입사 전인 2월 중순부터 살펴볼 수 있었다. 외주 개발물에 대해 파악한 내용을 개인적인 감상/비평은 최대한 자제하고 그냥 사실만 적도록 하겠다. 기 개발 기간외주 개발자들이 2019년 7월부터 2~3명의 인원이 붙어서 작업했다. 단순 M/M만 따져봐도 2월 당시엔 최소 14M/M가 된다. 백엔드서버 코드는 천만 다행으로 ES6+를 사용하고 있었고 node.js/Express 상에서 동작했다. 코드를 보니 미들웨어가 상당히 많았는데 이는 다년간 node.js 프로젝트를 진행했고 외주 회사에서 어느정도 프레임워크로 갖춰놓았다는 얘기가 된다. ESLint를 적용하진 않았고 유닛테스트가 없다. ㅠㅠ 인증인증은 JWT였다. OIDC나 OAuth0 썼을까 살짝 기대했는데 그건 아니고 생짜 인증키로 토큰을 만들고 내려주는 형태였다. Database데이터베이스는 MySQL 8.0이었다. ORM을 쓰지 않고 생짜 MySQL Driver를 사용했다. 근데 테이블이 70개가 넘었다. 프론트엔드React.js 다. ES6+를 사용했고 Redux로 전역 상태관리를 했다. 일부 컴포넌트는 Styled Component를 사용했으나 전체 스타일은 7000줄에 달하는 거대한 CSS가 담당하고 있었다. 스토리북으로 뭔가 테스트를 도입하려고 한것 같은데 테스트가 3개밖에 없다. 하다가 중단한듯 하다. 어드민 페이지는 별도의 프로젝트로 있었는데 Material UI로 만들어져 있었다. 인프라AWS를 사용했다. dev/prod 로 각각 EC2를 띄워서 사용했는데 이상하게 EC2가 4대나 되었다. 잘 살펴보니 Frontend Serve용 dev/prod 2대, Backend용 dev/prod 2대 이렇게 4대였다. DB는 하나의 EC2에 넣지 않고 AWS RDS를 사용하고 있었다. 오토스케일링 설정은 하지 않았고 Elastic IP를 받아서 Route53에서 A레코드에 해당 IP를 매핑하는 식으로 웹 서비스를 구성했다. 주로 사용하는 서비스는 사실 이게 다였다. 프론트엔드 웹서버는 serve 를 사용하고 있었고 API 서버는 nginx를 사용하고 있었다. 배포프론트엔드/백엔드 모두 배포는 CI/CD는 없었고 로컬 컴퓨터에서 스크립트로 배포했다. 단계는 아래와 같다 npm run build로 빌드 docker build 도커 이미지를 만들고 태깅한다. ECR에 올린다 EC2에 SSH로 접속해서 Docker Pull을 땡긴다 scp를 사용해서 docker-compose파일을 EC2로 복사한다. docker-compose 실행 기존 이미지를 지운다 끝 물론 대부분 다시 손을 봐야된다. 허나 이 정도만 되도 굉장히 감사한 편이다.지인의 요청으로 기존에 만들어놓은 외주 프로젝트를 본 일이 여러 번 있었는데 PHP 5.x로 코드이그나이터도 안쓰고 짠 소스 + 무식하게 큰 EC2 한 대에 웹서버 + 디비까지 같이 넣어놔서 오토스케일링도 못하게 만든게 제일 최악이었다. 거기에 비하면 이 정도는 사실 감사하다고 인사하고 써야할 것 같다. 자, 이를 어떻게 바꿀지는 3편부터… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/04/18/외주-레거시로부터의-여정-1편/"},{"title":"외주 레거시로부터의 여정 4편","text":"간만에 쓴다. 원래 4월 말에 적은 이후에 갑자기 너무 바빠져서 기억 저편에 사라져 있다가 갑자기 생각나서 이제서야 적는다. 원래 4월달에 적은 글인데, 이제야 퍼블리싱한다 : &gt; DB/Model휴… 한숨이 먼저 나온다. 외주 코드가 엉망이라서가 아니라 이 안에는 굉장한 쿼리가 숨어있어서 반은 존경, 반은 어휴 이걸 어떻게 라는 한숨이 나왔던 것이었다. 1편에서 말한대로 외주 코드에서는 Model을 따로 정의했고 MySQL Driver로 Raw Query를 사용했다. 여기까지는 좋은데 테이블이 지나치게 많은 경향이 있었다. 예를 들어 컨테이너 종류를 따로 테이블로 만들었는데, 사실 20피트 드라이 컨테이너가 없어질 일도 없고 새로운 규격의 컨테이너가 나올 가능성은 굉장히 희박하다. 따라서 컨테이너 정보는 필요한 테이블에서 enum 으로 관리해서 넣어도 무방했다. 또한 파일정보 관련된 테이블만 10여개에 달했는데 기업별 로고 파일 정보를 저장한 테이블, 소개자료 정보를 저장한 테이블 등등. 테이블 컬럼도 거의 동일하기 때문에 하나로 통합하고 플래그로 구분하면 될 일이었다. 뭐 그 당시에는 다 계획된 일이 있어서 만들었기 때문에 절대 비난한 일은 아니지만 지금 보면 좀 아쉽긴 하다. DB는 Sequelize ORM을 도입했다. 다만 모든 쿼리를 Sequelize Query로 짜진 못했는데 아래와 같은 무지막지한 쿼리 때문이었다. 1234567891011121314151617181920212223242526272829303132333435SELECT SQL_CALC_FOUND_ROWS DISTINCT u1.id, f1.id AS column1, u1.company, isCertifiedBL, isBelieve, column4, column5, column6, column7, column8, avgStars, reviewCount, fl1.src as logo, (SELECT JSON_ARRAYAGG(JSON_OBJECT(&apos;name&apos;, c1.name)) AS SAMPLE8 FROM SAMPLE1 fj1 INNER JOIN SAMPLE8 c1 on fj1.cityId = c1.id WHERE f1.id = fj1.column1) SAMPLE8, (SELECT JSON_ARRAYAGG(JSON_OBJECT(&apos;name&apos;, si1.name)) AS services FROM Services s1 INNER JOIN SAMPLE2 si1 on s1.column2 = si1.id WHERE s1.userId = f1.userId) services, (SELECT JSON_ARRAYAGG(JSON_OBJECT(&apos;name&apos;, fs1.name)) AS ffff FROM SAMPLE3 fss1 INNER JOIN SAMPLE4 fs1 on fss1.column3 = fs1.id WHERE fss1.column1 = f1.id) ffff, ffair1.price, ffair1.expiredAt FROM Forwarders f1 INNER JOIN SAMPLE9 u1 on f1.userId = u1.id LEFT JOIN SAMPLE10 s1 on s1.userId = u1.id LEFT JOIN SAMPLE1 fj1 on f1.id = fj1.column1 LEFT JOIN SAMPLE8 c1 on fj1.cityId = c1.id LEFT JOIN SAMPLE2 si1 on s1.column2 = si1.id LEFT JOIN SAMPLE3 fss1 on fss1.column1 = f1.id LEFT JOIN SAMPLE4 fs1 on fss1.column3 = fs1.id INNER JOIN SAMPLE5 ff1 on f1.id = ff1.column1 AND ff1.column11 = blahblah LEFT JOIN SAMPLE6 fl1 on u1.id = fl1.userId INNER JOIN ( SELECT ff2.column12, ff2.colume24 AS price, expiredAt FROM SAMPLE5LCL fflcl1 WHERE column22 = &apos;blahblah&apos; AND column23 = &apos;bbbb&apos; AND DATE_FORMAT(DATE_ADD(NOW(), INTERVAL 9 HOUR), &apos;%Y-%m-%d&apos;) &lt; expiredAt ) fflcl1 on ff1.id = fflcl1.column24 중요 내용은 다 텍스트 대체했고 귀찮아서 뒤에 10줄은 다 적지 않아서 유효한 SQL문은 아니다. 다만 이런식의 쿼리를 만나니 정말 정신이 혼미했다… 여태까지 테이블 10개씩 조인하는 쿼리는 처음이었다. 자연의 위대함 앞에 선 인간의 심정이 이러할까 싶다. 이렇게 Join이 많은 쿼리는 그냥 그대로 Raw Query형태로 사용하기로 했고, 단순 findOne, findAll, Create, Update 정도만 Sequelize 를 사용하기로 결정했다. 이렇게 조인이 많으면 시퀄라이즈에서 쿼리 구성하는데 백 만년이 걸릴것 같았다. 중요한건 쿼리랑 그 타입 정보가 있는 결과값이지 그 형태가 중요한건 아니니까 TypeORM 도입도 생각했는데, 당시 백엔드 개발자가 나 혼자뿐이고 사용 경험이 없어서 그냥 익숙한 걸로 사용했다. 그 후거의 90개의 테이블을 외주로부터 인수인계를 받았는데 받았는데 비즈니스 모델이 계속 변경됨에 따라 금방 100개가 넘어갔다. 솔직히 하는 일에 비해서 테이블 수가 너무 많았던지라, 얼마 전(11월 말)에 한 번 대대적인 리팩토링을 해서 현재는 70개선으로 유지 중이며 앞으로 20개를 살생부에 올려놓은 상황이다. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/12/02/외주-레거시로부터의-여정-4편/"},{"title":"EKS 503 탈출기","text":"EKS를 처음 구축하고 나를 반겨준 화면은 단연 503 Service Unavailable 이었다. ㅠㅠ 문제의 원인은 Pod, Service, Ingress 혹은 이미지 자체에 있을 수 있다. 문제점을 찾기 위해서 아래와 같은 순서대로 확인했다. Pod가 정상 동작 중인지 확인먼저 pod가 동작 중인지 확인한다. 12345$ kubectl get podsNAME READY STATUS RESTARTS AGEshipda-api-v2-7b45cdf6df-7hfsk 1/1 Running 0 2d12hshipda-api-v2-7b45cdf6df-b8hzq 1/1 Running 0 2d12hshipda-api-v2-7b45cdf6df-v24vh 1/1 Running 0 2d12h 뭐 다들 정상 동작중이니 이미지를 확인해본다. 이미지 검사Pod에 올라간 도커 이미지가 진짜로 제대로 도는지 확인해본다. 다만 이는 Health Check를 잘 만들어놨다면 좀 쉽게 체크할 수 있다. 1kubectl port-forward pod/shipda-api-v2-7b45cdf6df-7hfsk 8080:8080 해당 Pod의 8080포트를 localhost 8080 포트에 바인딩시킨다. 그 후 로컬호스트의 8080포트에 대고 API를 테스트해본다. 여기까지 문제가 없으면 Service 혹은 Ingress가 문제다. 서비스원인은 인그레스가 서비스를 못찾거나 서비스가 Deployment 를 못찾거나 이 둘 중 하나로 좁혀졌다. 하지만 어디서 문제인지 도통 알 수가 없었다. 그래서 옆에 곰돌이를 앉혀놓고 다시 한 번 서비스를 확인해본다. 123456789101112131415$ kubectl describe service -n shipdaName: shipda-api-v2Namespace: shipdaLabels: &lt;none&gt;Annotations: kubectl.kubernetes.io/Selector: run=shipda-api-v2Type: NodePortIP: 10.100.75.73Port: &lt;unset&gt; 80/TCPTargetPort: 8080/TCPNodePort: &lt;unset&gt; 30888/TCPEndpoints: 172.31.1.205:8080,172.31.21.125:8080,172.31.39.55:8080Session Affinity: NoneExternal Traffic Policy: ClusterEvents: &lt;none&gt; deployment는123456789apiVersion: apps/v1kind: Deploymentmetadata: name: shipda-api-v2 labels: app: shipda-api-v2 namespace: shipdaspec:... 곰돌이에게 deployment의 metadata를 설명하다가 갑자기 뜨얽!Deployment에서는 label을 app: shipda-api-v2 로 해놨는데 Service Selector는 run: shipda-api-v2 로 해놓았던 것이었다! 따라서 잉그레스 -&gt; 서비스 -&gt; 디플로이먼트 이렇게 흘러가야할 트래픽이 서비스에서 디플로이먼트로 흘러가지 못해서 503에러가 발생했다. 왜 selector를 run으로 한지 이유는 모르겠지만… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/03/30/EKS-503-탈출기/"},{"title":"현재 개발자 채용 시장에 대한 작은 생각","text":"최근 회사에서 개발자를 뽑고 있다. 2년차 이상 웹 개발자를 뽑기 시작한지 1달이 다 되어가는데 생각보다 이력서가 많이 모이지 않았다. 현재 회사에서는 Node.js, Express, React.js, Mongodb + Mongoose, Typescript, Azure 을 사용하고 있는데 이 개발 스택에 해당하는 개발자가 없는지, 아니면 다른 곳에서 너무 많이 뽑아서 내가 다니는 회사까지 온기가 오기 않는건지 궁금해서 로켓펀치와 윈티드 구인 공고를 훑어봤다. 아래는 나의 주관적인 생각이다. 객관적인 데이터는 없지만 시비 걸지는 말아주시길 : ) 백엔드 언어 백엔드 언어는 Java 35%, Python 20%, PHP 20%, Node.js 10%, C# &amp; Ruby &amp; Go &amp; 기타 15% 자바가 제일 많다. 토스, 배민, 네이버 등 크고 유명한 곳에서 Spring을 사용하고 있기 때문일거다. 생각보다 PHP가 많은데 보통은 Laravel 개발자를 뽑는 경우가 많았다. 근데 Laravel이 Full Web Framework라서 편하긴 하지만 이걸로 API 서버를 만들면 성능이 안날텐데… 왜들 쓰는지 모르겠다. Show me the money라면 어느 정도 부하를 처리할 수 있겠지 ㅎㅎ 파이썬은 Flask는 별로 없고 Django가 많다. 가끔씩 Sanic 쓰는 곳도 있더라. 다만 파이썬은 백엔드 분야 외 데이터 분야 등 다양하게 쓰여서 공고가 많을 지도. 노드는 생각보다 별로 없다. 좀 의외다. 주로 쓰는 곳은 작은 스타트업. C#, Ruby, Go, 기타 합해서 15% 정도다. Ruby, C#, Go 언어 순으로 공고가 많았다. Rust를 메인 백엔드로 쓰는 곳은 아직 본 적이 없다. Go는 간간히 눈에 띄지만 거의 없다. 한국에서 C#은 쉽지 않겠다. Ruby는 과거보다 위상이 많이 떨어졌고, 지금도 떨어지는 듯 하다. 기타로는 Scala가 있다. 데이터 분석 분야와 뱅크샐러드에서 많이 쓰는 듯. 프론트엔드 언어React 60%, Vue.js 25%, Angular + jQuery 15% 클라우드AWS 천하통일. 간간히 GCP가 있고 희귀하게 Azure가 있다. 스타트업 중에서는 Azure를 쓰는 곳을 거의 못봤다. 앗! 이것 때문에 지원을 안하는 겐가! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/05/13/korean-developer-job-distribution/"},{"title":"ECMAScript(Javascript) 호이스팅","text":"호이스팅(Hosting)은 자바스크립트 인터프리터가 변수 및 함수의 선언을 항상 코드 상단으로 올리는 행위를 말한다. 엄밀하게 얘기하자면 컴파일 단계에서 변수 및 함수의 선언을 먼저 읽어서 메모리 상에 저장해두는 행위에 가깝다. 예제 코드를 한 번 보자. 123a = 1;console.log(&apos;Result:&apos;, a);var a; 이 코드의 실행 결과는 아래와 같다.1Result: 1 알다시피 자바스크립트는 변수를 선언하기 전에 사용할 수 있다. 코드 1행에서 선언하지도 않았던 a에 1을 할당했고 2행에서 콘솔에 출력한 결과가 제대로 출력되었다. 정작 변수 a는 3행에서야 나타난다. 이를 호이스팅(hoisting)이라 한다. 호이스팅의 원형 hoist는 사전적 의미로 밧줄이나 장비를 이용하여 끌어올리다는 뜻이 있다. 이렇게 자바스크립트 인터프리터는 컴파일 단계에서 변수 및 함수의 선언을 항상 컨텍스트의 상단으로 끌려올린다. 인터프리터가 선언 코드를 물리적으로 상단으로 올리는 건 아니다. 다만 변수와 함수 선언을 컴파일 단계에서 메모리에 올려두고 undefined 값을 할당한다. 그 후에 코드를 실행하기 때문에 선언이 뒤에 있더라도 선언 앞에서 해당 변수를 사용할 수 있다. 다만 선언에 강조를 한 이유는 초기화 코드는 호이스팅의 대상이 아니기 때문이다.123var a = 5;console.log(&apos;a: %d b: %d&apos;, a, b);var b = 7; 위 코드를 크롬 콘솔에서 실행하면 아래의 결과가 나온다.1a: 5 b: NaN 자바스크립트 인터프리터가 위 코드를 호이스팅하면 아래와 같은 형태로 코드를 읽어들인다.12345var a;var b;a = 5;console.log(&apos;a: %d b: %d&apos;, a, b)b = 7; 즉 인터프리터는 컴파일 단계에서 변수 a와 b를 메모리 상에 올려두고 undefined 값을 할당해 둔다. 다만 호이스팅은 선언만을 대상으로 하기 때문에 초기화 구문은 해당되지 않는다. 따라서 console로 값을 찍을 무렵에는 a에는 5만 할당되어 있고 b는 undefined 상태가 된다. 함수도 호이스팅의 영향을 받는다. 함수 선언식이 호이스팅의 영향을 받는다. 자바스크립트에서 함수를 사용하는 방식을 잠깐 설명하자면 자바스크립트에서 함수를 사용하는 방식은 함수 선언식(Function Declaration)과 함수 표현식(Function Expression)으로 구분할 수 있다. 함수 선언식은 다른 프로그래밍 언어에서 사용하는 함수 선언식과 동일하다.123function functionDeclaration() { // 함수 내용} 함수 표현식은 아래와 같다. Go언어같은 최신 언어에서는 자바스크립트와 같은 함수 표현식을 많이 지원하기도 한다.123var functionExpr = function() { // 함수 내용} 예를 들어 아래와 같은 코드가 있다면,12345678910funcDecl();funcExpr();function funcDecl() { return &apos;decl!&apos;;}var funcExpr = function() { return &apos;expr!&apos;;} 호이스팅때문에 인터프리터는 아래와 같이 해석한다.12345678910function funcDecl() { return &apos;decl!&apos;;}var funcExpr;funcDecl();funcExpr();funcExpr = function() { return &apos;expr!&apos;;} 따라서 funcExpr()를 실행할 시점에는 funcExpr()이 정의되지 않았기 때문에 크롬에서 실행하면 아래와 같은 결과가 나온다.1Uncaught TypeError: funcExpr is not a function 이 호이스팅 때문에 의도하지 않은 버그를 내기도 한다. 문제는 자바스크립트 인터프리터의 동작을 이해하지 못하는 사람이 코드를 짜면 버그가 잘 날 수 있다는 사실, 그리고 그 버그가 나오면 찾기 어렵다는 문제가 있다. ~C계열의 undefined behavior의 향기가…따라서 호이스팅을 막으려면 선언을 함수나 전역 상단에 적기 let 사용 strict 모드 사용 - use strict 을 사용 시 선언하지 않은 변수를 사용할 수 없다. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/05/19/About-ECMAScript-Hoisting/"}],"tags":[{"name":"프로그래머","slug":"프로그래머","link":"/tags/프로그래머/"},{"name":"채용","slug":"채용","link":"/tags/채용/"},{"name":"스타트업","slug":"스타트업","link":"/tags/스타트업/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/tags/ECMAScript/"},{"name":"use strict","slug":"use-strict","link":"/tags/use-strict/"},{"name":"자바스트립트","slug":"자바스트립트","link":"/tags/자바스트립트/"},{"name":"엄격 모드","slug":"엄격-모드","link":"/tags/엄격-모드/"},{"name":"google cloud platform","slug":"google-cloud-platform","link":"/tags/google-cloud-platform/"},{"name":"GCP","slug":"GCP","link":"/tags/GCP/"},{"name":"App Engine","slug":"App-Engine","link":"/tags/App-Engine/"},{"name":"구글 클라우드 플랫폼","slug":"구글-클라우드-플랫폼","link":"/tags/구글-클라우드-플랫폼/"},{"name":"앱엔진","slug":"앱엔진","link":"/tags/앱엔진/"},{"name":"구글 앱 엔진","slug":"구글-앱-엔진","link":"/tags/구글-앱-엔진/"},{"name":"Firebase","slug":"Firebase","link":"/tags/Firebase/"},{"name":"Firestore","slug":"Firestore","link":"/tags/Firestore/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"파이어스토어","slug":"파이어스토어","link":"/tags/파이어스토어/"},{"name":"파이어베이스","slug":"파이어베이스","link":"/tags/파이어베이스/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"jest","slug":"jest","link":"/tags/jest/"},{"name":"Unit test","slug":"Unit-test","link":"/tags/Unit-test/"},{"name":"유닛 테스트","slug":"유닛-테스트","link":"/tags/유닛-테스트/"},{"name":"Google Cloud Platform","slug":"Google-Cloud-Platform","link":"/tags/Google-Cloud-Platform/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"appengine","slug":"appengine","link":"/tags/appengine/"},{"name":"datastore","slug":"datastore","link":"/tags/datastore/"},{"name":"삽질","slug":"삽질","link":"/tags/삽질/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"npm 패키지","slug":"npm-패키지","link":"/tags/npm-패키지/"},{"name":"npm 퍼블리싱","slug":"npm-퍼블리싱","link":"/tags/npm-퍼블리싱/"},{"name":"에이팀벤쳐스","slug":"에이팀벤쳐스","link":"/tags/에이팀벤쳐스/"},{"name":"에이팀벤쳐스 근무환경","slug":"에이팀벤쳐스-근무환경","link":"/tags/에이팀벤쳐스-근무환경/"},{"name":"에이팀벤쳐스 잡플래닛","slug":"에이팀벤쳐스-잡플래닛","link":"/tags/에이팀벤쳐스-잡플래닛/"},{"name":"코딩테스트","slug":"코딩테스트","link":"/tags/코딩테스트/"},{"name":"EKS","slug":"EKS","link":"/tags/EKS/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"RDS","slug":"RDS","link":"/tags/RDS/"},{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"},{"name":"타입스크립트","slug":"타입스크립트","link":"/tags/타입스크립트/"},{"name":"프로그래밍","slug":"프로그래밍","link":"/tags/프로그래밍/"},{"name":"외주","slug":"외주","link":"/tags/외주/"},{"name":"레거시","slug":"레거시","link":"/tags/레거시/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"노드","slug":"노드","link":"/tags/노드/"},{"name":"데이터베이스","slug":"데이터베이스","link":"/tags/데이터베이스/"},{"name":"쿠버네티스","slug":"쿠버네티스","link":"/tags/쿠버네티스/"},{"name":"Elastic Kubernetes Service","slug":"Elastic-Kubernetes-Service","link":"/tags/Elastic-Kubernetes-Service/"},{"name":"개발자 구직시장","slug":"개발자-구직시장","link":"/tags/개발자-구직시장/"},{"name":"개발자 구인시장","slug":"개발자-구인시장","link":"/tags/개발자-구인시장/"},{"name":"Hoisting","slug":"Hoisting","link":"/tags/Hoisting/"},{"name":"호이스팅","slug":"호이스팅","link":"/tags/호이스팅/"}],"categories":[{"name":"개발일기","slug":"개발일기","link":"/categories/개발일기/"},{"name":"programming","slug":"programming","link":"/categories/programming/"},{"name":"cloud","slug":"cloud","link":"/categories/cloud/"},{"name":"일반","slug":"개발일기/일반","link":"/categories/개발일기/일반/"},{"name":"node","slug":"programming/node","link":"/categories/programming/node/"},{"name":"javascript","slug":"programming/javascript","link":"/categories/programming/javascript/"},{"name":"golang","slug":"programming/golang","link":"/categories/programming/golang/"},{"name":"GCP","slug":"cloud/GCP","link":"/categories/cloud/GCP/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"GCP","slug":"programming/GCP","link":"/categories/programming/GCP/"},{"name":"vue.js","slug":"programming/javascript/vue-js","link":"/categories/programming/javascript/vue-js/"},{"name":"k8s","slug":"AWS/k8s","link":"/categories/AWS/k8s/"}]}